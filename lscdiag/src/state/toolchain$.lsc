import { switchLatest, map, fromPromise, combineLatest, toBehaviorSubject } from '@ormojo/fobs'
import { InPlacePlatform } from '@lightscript/compiler-platform'
import createMarker from '../utils/createMarker'

platform = new InPlacePlatform()

makeCaller() ->
  // Memoize one layer of tools since we expect input to change often
  // but tool to remain relatively fixed
  let memoizedAction = null
  let previousSpec = null
  let previousDescriptor = null
  callTool(toolSpec, input) -/>
    try:
      if (toolSpec == previousSpec) and memoizedAction:
        result <- memoizedAction.run(input)
        { descriptor: previousDescriptor, result }
      else:
        tool <- platform.createTool(toolSpec)
        now previousSpec = toolSpec
        now previousDescriptor <- tool.describe(true)
        console.log("toolchain regenerated, new descriptor", previousDescriptor)
        now memoizedAction <- tool.apply(null)
        result <- memoizedAction.run(input)
        { descriptor: previousDescriptor, result }
    catch err:
      console.error("ToolchainError", err)
      { descriptor: previousDescriptor, result: { error: err } }

export toolchain$(obs) ->
  callTool = makeCaller()

  obs
  ~map! ([opts, input]) ->
    fromPromise(callTool(opts, input))
  ~switchLatest!

export default toolchainCompiled$(fixture) ->
  let memoizedDescriptor = null
  combineLatest([
    fixture.config.get
    fixture.input.get
  ])
  ~toolchain$()
  ~map! ({ descriptor, result }) ->
    // Feed the toolchain descriptor back to the fixture
    if descriptor and descriptor != memoizedDescriptor:
      now memoizedDescriptor = descriptor
      fixture.toolchainDescriptor$.next(descriptor)

    // Broadcast errors on separate observable
    if result.error:
      marker = if result.error.loc: createMarker('hlt_error', result.error.loc)
      fixture.errors$.next([{error: result.error, marker}])
    else:
      fixture.errors$.next(null)

    result
  ~toBehaviorSubject()
