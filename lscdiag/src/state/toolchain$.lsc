import { switchLatest, map, fromPromise, combineLatest, toBehaviorSubject, createConstant } from '@ormojo/fobs'
import { InPlacePlatform } from '@lightscript/compiler-platform'
import createMarker from '../utils/createMarker'

platform = new InPlacePlatform()

makeCaller() ->
  // Memoize one layer of tools since we expect input to change often
  // but tool to remain relatively fixed
  let memoizedAction = null
  let previousSpec = null
  let previousDescriptor = null
  callTool(toolSpec, input) -/>
    try:
      if (toolSpec == previousSpec) and memoizedAction:
        console.log("memoized")
        result <- memoizedAction.run(input)
        { descriptor: previousDescriptor, result }
      else:
        console.log("pezzimized")
        tool <- platform.createTool(toolSpec)
        now previousSpec = toolSpec
        now previousDescriptor <- tool.describe(true)
        now memoizedAction <- tool.apply(null)
        result <- memoizedAction.run(input)
        { descriptor: previousDescriptor, result }
    catch err:
      { toolchainError: err }

toolchain$(obs) ->
  callTool = makeCaller()

  obs
  ~map! ([opts, input]) ->
    fromPromise(callTool(opts, input))
  ~switchLatest!

defaultConfig = {
  source: {
    type: 'remote'
    url: 'https://wcjohnson.github.io/lightscript-compiler/modules/registry.js'
  }
}

export default toolchainCompiled$(fixture) ->
  combineLatest([
    createConstant(defaultConfig)
    fixture.source.code~map(x -> { code: x })
  ])
  ~toolchain$()
  ~map! ({ descriptor, result }) ->
    console.log("tool descriptor", descriptor)
    // If an error has a loc, create an error marker
    if result.error and result.error.loc:
      fixture.errorMarkers$.next([
        createMarker('hlt_error', result.error.loc)
      ])
    else:
      fixture.errorMarkers$.next(null)
    result
  ~toBehaviorSubject()
