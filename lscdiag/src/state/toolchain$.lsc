import { switchLatest, map, fromPromise, combineLatest, toBehaviorSubject } from '@ormojo/fobs'
import { InPlacePlatform } from '@lightscript/compiler-platform'
import createMarker from '../utils/createMarker'

platform = new InPlacePlatform()

makeCaller() ->
  // Memoize one layer of tools since we expect input to change often
  // but tool to remain relatively fixed
  let memoizedAction = null
  let previousSpec = null
  let previousDescriptor = null
  callTool(toolSpec, input) -/>
    try:
      if (toolSpec == previousSpec) and memoizedAction:
        result <- memoizedAction.run(input)
        { descriptor: previousDescriptor, result }
      else:
        tool <- platform.createTool(toolSpec)
        now previousSpec = toolSpec
        now previousDescriptor <- tool.describe(true)
        console.log("toolchain regenerated, new descriptor", previousDescriptor)
        now memoizedAction <- tool.apply(null)
        result <- memoizedAction.run(input)
        { descriptor: previousDescriptor, result }
    catch err:
      console.error("ToolchainError", err)
      { result: { toolchainError: err } }

toolchain$(obs) ->
  callTool = makeCaller()

  obs
  ~map! ([opts, input]) ->
    fromPromise(callTool(opts, input))
  ~switchLatest!

export default toolchainCompiled$(fixture) ->
  combineLatest([
    fixture.config.get~map(x ->
      console.log("pushing config to toolchain:", x)
      x
    )
    fixture.source.code~map(x -> { code: x })
  ])
  ~toolchain$()
  ~map! ({ descriptor, result }) ->
    // Feed the toolchain descriptor back to the fixture
    if descriptor:
      fixture.toolchainDescriptor$.next(descriptor)
    // If an error has a loc, create an error marker
    if result.error and result.error.loc:
      fixture.errorMarkers$.next([
        createMarker('hlt_error', result.error.loc)
      ])
    else:
      fixture.errorMarkers$.next(null)
    result
  ~toBehaviorSubject()
